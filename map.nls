;; Add a QUAD node by giving 4 corners (in PATCH coords).
;; Order corners either clockwise or counter-clockwise.
to add-quad-node [x1 y1 x2 y2 x3 y3 x4 y4 id kind rule]
  let pts (list (list x1 y1) (list x2 y2) (list x3 y3) (list x4 y4))
  add-poly-node pts id kind rule
end

; meters -> patches wrapper
to add-quad-node-m [x1m y1m x2m y2m x3m y3m x4m y4m id kind rule]
  ; use round if you want patch-aligned corners
  let x1 (x1m / meters-per-patch)
  let y1 (y1m / meters-per-patch)
  let x2 (x2m / meters-per-patch)
  let y2 (y2m / meters-per-patch)
  let x3 (x3m / meters-per-patch)
  let y3 (y3m / meters-per-patch)
  let x4 (x4m / meters-per-patch)
  let y4 (y4m / meters-per-patch)
  add-quad-node x1 y1 x2 y2 x3 y3 x4 y4 id kind rule
end


;; Add a POLYGON node (any number of corners ≥ 3), PATCH coords.
to add-poly-node [pts id kind rule]
  ;; quick bounding box to limit checks
  let xs map [p -> item 0 p] pts
  let ys map [p -> item 1 p] pts
  let xmin floor min xs
  let xmax ceiling max xs
  let ymin floor min ys
  let ymax ceiling max ys
  
  ask patches with [pxcor >= xmin and pxcor <= xmax and
                    pycor >= ymin and pycor <= ymax] [
    let x pxcor
    let y pycor
    if point-in-poly-or-edge? x y pts [
      set node-id id
      set node-kind kind
      set node-rule rule
    ]
  ]
end


;; =============== RULES ========================
;; Returns a vector [dx dy] for the patch at position (x,y)
;; Assumes patches-own [nodeKind nodeRule]
to-report rule-for-pos [x y]
  let p patch x y
  if p = nobody [ report (list 0 0) ]  ;; safety

  let kind [node-kind] of p
  let rule [node-rule] of p

  if kind = "goal" [
    report ifelse-value (length rule = 2)
      [ vec-goal-certain   x y rule ]
      [ vec-goal-uncertain x y rule ]
  ]

  if kind = "direction" [
    report ifelse-value (length rule = 2)
      [ vec-dir-certain   x y rule ]
      [ vec-dir-uncertain x y rule ]
  ]

  ;; default if kind unrecognized
  report (list 0 0)
end


;; ========== GOAL rules ==========

;; nodeRule (certain GOAL): [gx gy]
to-report vec-goal-certain [x y rule]
  let gx item 0 rule
  let gy item 1 rule
  report (list (gx - x) (gy - y))
end

;; nodeRule (uncertain GOAL): [gx1 gy1 p1 gx2 gy2 p2 ...]
;; probabilities can be arbitrary weights; normalized automatically
to-report vec-goal-uncertain [x y rule]
  let nRule length rule
  if nRule < 6 [ report vec-goal-certain x y rule ]  ;; need at least (gx gy p)
  
  ;; --- total weight ---
  let total 0
  let i 0
  while [i < nRule] [
    set total total + item (i + 2) rule
    set i i + 3
  ]
  
  ;; --- random draw ---
  let u random-float total
  let cum 0
  set i 0
  while [i < nRule] [
    set cum cum + item (i + 2) rule
    if u < cum [
      let gx item i rule
      let gy item (i + 1) rule
      report (list (gx - x) (gy - y))
    ]
    set i i + 3
  ]
  
  ;; fallback (should not happen)
  report (list 0 0)
end



;; ========== DIRECTION rules ==========

;; nodeRule (certain DIRECTION): [dirx diry]
to-report vec-dir-certain [x y rule]
  ;; x,y unused here but kept for consistent signature
  let dirx item 0 rule
  let diry item 1 rule
  report (list dirx diry)
end

;; nodeRule (uncertain DIRECTION): [dx1 dy1 p1 dx2 dy2 p2 ...]
;; probabilities p_i can sum to anything; we normalize implicitly
to-report vec-dir-uncertain [x y rule]
  let nRule length rule
  if nRule < 6 [ report vec-dir-certain x y rule ]  ;; safety fallback (needs at least 2 dirs + probs)

  ;; total weight
  let total 0
  let i 0
  while [i < nRule] [
    set total total + item (i + 2) rule
    set i i + 3
  ]

  ;; draw and pick
  let u random-float total
  let cum 0
  set i 0
  while [i < nRule] [
    set cum cum + item (i + 2) rule
    if u < cum [
      report (list (item i rule) (item (i + 1) rule))
    ]
    set i i + 3
  ]

  ;; fallback (numerical edge case)
  report (list 0 0)
end



;; =============== GEOMETRY HELPERS ========================

;; inclusive test: inside polygon OR exactly on an edge
to-report point-in-poly-or-edge? [x y pts]
  if point-on-any-edge? x y pts [ report true ]
  report point-in-poly? x y pts
end

;; classic even–odd (ray casting). Works for convex/concave polygons.
to-report point-in-poly? [x y pts]
  let inside? false
  let nPoints length pts
  let j nPoints - 1
  let i 0
  while [i < nPoints] [
    let xi item 0 item i pts
    let yi item 1 item i pts
    let xj item 0 item j pts
    let yj item 1 item j pts

    ;; edge crosses the horizontal ray upward/downward?
    if (((yi > y) != (yj > y)) and
        (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.0) + xi)) [
      set inside? not inside?
    ]
    set j i
    set i i + 1
  ]
  report inside?
end

;; boundary inclusion (point lies on any polygon segment)
to-report point-on-any-edge? [x y pts]
  let nPoints length pts
  let j nPoints - 1
  let i 0
  while [i < nPoints] [
    let x1 item 0 item j pts
    let y1 item 1 item j pts
    let x2 item 0 item i pts
    let y2 item 1 item i pts
    if point-on-seg? x y x1 y1 x2 y2 [ report true ]
    set j i
    set i i + 1
  ]
  report false
end

;; point-on-line-segment test with bounding-box check
to-report point-on-seg? [x y x1 y1 x2 y2]
  ;; quick reject by bounding box
  let xmin min list x1 x2
  let xmax max list x1 x2
  let ymin min list y1 y2
  let ymax max list y1 y2
  if not (x >= xmin and x <= xmax and y >= ymin and y <= ymax) [
    report false
  ]

  ;; colinearity via cross product ≈ 0 (tolerance for integer/float math)
  let cross ((x - x1) * (y2 - y1) - (y - y1) * (x2 - x1))
  report (abs cross) <= 1e-6
end




;; --- ONE BIG NODE for layout-a ---
to build-node-layout-a
  ;; doors-layout-a -> [(x y visibility id)], take the first (and only) door
  let d first doors-layout-a
  let gx round item 0 d
  let gy round item 1 d

  ask patches [
    set node-id 1
    set node-kind "goal"
    set node-rule (list gx gy)   ;; certain GOAL: [gx gy]
  ]
end