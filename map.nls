;; ==============================================
;; =============== RULES ========================
;; ==============================================
;; Returns a vector [dx dy] for the patch at position (x,y)
;; Assumes patches-own [nodeKind nodeRule]
to-report rule-for-pos [x y]
  let p patch x y
  if p = nobody [ report (list 0 0) ]  ;; safety

  let kind [node-kind] of p
  let rule [node-rule] of p

  if kind = "goal" [
    report ifelse-value (length rule = 2)
      [ vec-goal-certain   x y rule ]
      [ vec-goal-uncertain x y rule ]
  ]

  if kind = "direction" [
    report ifelse-value (length rule = 2)
      [ vec-dir-certain   x y rule ]
      [ vec-dir-uncertain x y rule ]
  ]
  
  if kind = "next-node" [
    report ifelse-value (length rule = 1)
      [ vec-next-node-certain   x y rule ]
      [ vec-next-node-uncertain x y rule ]
  ]

  ;; default if kind unrecognized
  report (list 0 0)
end


;; ========== NEXT NODE rules ==========

;; nodeRule (NEXT NODE certain): rule = target node-id (number or string)
;; Returns a unit vector [dx dy] from (x,y) toward the closest patch with node-id = rule
to-report vec-next-node-certain [ x y rule ]
  ;; rule may be a list or a bare value
  let rule-id ifelse-value is-list? rule [ item 0 rule ] [ rule ]

  ;; (optional) normalize type to string if your patch node-ids are strings
  ;; if not is-string? rule-id [ set rule-id (word rule-id) ]

  let targets patches with [ node-id = rule-id ]
  if not any? targets [ report (list 0 0) ]  ;; no targets → zero vector

  ;; closest patch to (x,y)
  let p min-one-of targets [ distancexy x y ]
  
  report p
end


;; nodeRule (NEXT NODE uncertain):
;; rule examples:
;;   [1 2 3]                → uniform between node-ids 1,2,3
;;   [1 0.7  2 0.3]         → weighted: 70% → node 1, 30% → node 2
to-report vec-next-node-uncertain [x y rule]
  let ruleLen length rule
  if ruleLen < 1 [ report (list 0 0)]

  ;; ===== determine if weighted or uniform =====
  let weighted? (ruleLen mod 2 = 0)   ;; even length ⇒ has weights (id,prob,id,prob,...)

  let chosen-id nobody

  ifelse weighted? [
  ;; ---- weighted random draw ----
    let total 0
    let i 0
    while [i < ruleLen] [
      set total total + item (i + 1) rule
      set i i + 2
    ]
    let pick random-float total
    let cum 0
    set i 0
    while [i < ruleLen] [
      set cum cum + item (i + 1) rule
      if pick < cum [
        set chosen-id item i rule
        set i ruleLen
      ]
      set i i + 2
    ]
  ] [
    ;; ---- uniform choice ----
    set chosen-id one-of rule
  ]

  ;; ===== now compute vector toward chosen node =====
  let targets patches with [node-id = chosen-id]
  if not any? targets [ report (list 0 0) ]

  let p min-one-of targets [ (pxcor - x) * (pxcor - x) + (pycor - y) * (pycor - y) ]
  report p
end


;; ========== GOAL rules ==========

;; nodeRule (certain GOAL): [gx gy]
to-report vec-goal-certain [x y rule]
  let gx item 0 rule
  let gy item 1 rule
  report (list (gx - x) (gy - y))
end

;; nodeRule (uncertain GOAL): [gx1 gy1 p1 gx2 gy2 p2 ...]
;; probabilities can be arbitrary weights; normalized automatically
to-report vec-goal-uncertain [x y rule]
  let nRule length rule
  if nRule < 6 [ report vec-goal-certain x y rule ]  ;; need at least (gx gy p)
  
  ;; --- total weight ---
  let total 0
  let i 0
  while [i < nRule] [
    set total total + item (i + 2) rule
    set i i + 3
  ]
  
  ;; --- random draw ---
  let u random-float total
  let cum 0
  set i 0
  while [i < nRule] [
    set cum cum + item (i + 2) rule
    if u < cum [
      let gx item i rule
      let gy item (i + 1) rule
      report (list (gx - x) (gy - y))
    ]
    set i i + 3
  ]
  
  ;; fallback (should not happen)
  report (list 0 0)
end



;; ========== DIRECTION rules ==========

;; nodeRule (certain DIRECTION): [dirx diry]
to-report vec-dir-certain [x y rule]
  ;; x,y unused here but kept for consistent signature
  let dirx item 0 rule
  let diry item 1 rule
  report (list dirx diry)
end

;; nodeRule (uncertain DIRECTION): [dx1 dy1 p1 dx2 dy2 p2 ...]
;; probabilities p_i can sum to anything; we normalize implicitly
to-report vec-dir-uncertain [x y rule]
  let nRule length rule
  if nRule < 6 [ report vec-dir-certain x y rule ]  ;; safety fallback (needs at least 2 dirs + probs)

  ;; total weight
  let total 0
  let i 0
  while [i < nRule] [
    set total total + item (i + 2) rule
    set i i + 3
  ]

  ;; draw and pick
  let u random-float total
  let cum 0
  set i 0
  while [i < nRule] [
    set cum cum + item (i + 2) rule
    if u < cum [
      report (list (item i rule) (item (i + 1) rule))
    ]
    set i i + 3
  ]

  ;; fallback (numerical edge case)
  report (list 0 0)
end

;;==================================================================================================================


to set-rect-direction [xmin xmax ymin ymax id dir-x dir-y]
  ask patches with [pxcor >= xmin and pxcor <= xmax and
                    pycor >= ymin and pycor <= ymax] [
    set node-id   id
    set node-kind "direction"
    set node-rule (list dir-x dir-y)         ;; direction vector
  ]
end

to set-rect-go-nearest [xmin xmax ymin ymax id doors]
  ;; doors is a list of (list x y vis door-id). We'll choose the nearest (x y).
  ask patches with [pxcor >= xmin and pxcor <= xmax and
                    pycor >= ymin and pycor <= ymax] [
    let gx 0
    let gy 0
    let best 1e9
    foreach doors [ d ->
      let dir-x pxcor - (item 0 d)
      let dir-y pycor - (item 1 d)
      let dist dir-x * dir-x + dir-y * dir-y
      if dist < best [
        set best dist
        set gx item 0 d
        set gy item 1 d
      ]
    ]
    set node-id   id
    set node-kind "goal"
    set node-rule (list round gx round gy)  ;; certain GOAL to nearest door
  ]
end
