; ==========
; Arrows
; ==========

to-report clamp [v lo hi]
  report min list hi (max list lo v)
end

;; Turtle-context arrow drawer (safe near borders)
to draw-vel-arrow-turtle [vx vy scale col]
  let sx xcor
  let sy ycor
  let ex sx + vx * scale
  let ey sy + vy * scale

  ;; clamp end to world bounds so setxy never goes out of range
  set ex clamp ex min-pxcor max-pxcor
  set ey clamp ey min-pycor max-pycor

  hatch 1 [
    hide-turtle
    set color col
    set pen-size 1
    setxy sx sy
    pen-down
    setxy ex ey   ;; now guaranteed in-bounds
    pen-up
    die
  ]
end

; ==========
; Visuals
; ==========

to-report mean-gamma-neighbors [radius]
  let nb other people in-radius radius
  if any? nb [ report mean [gamma] of nb ]
  report gamma   ;; fallback: keep own gamma if no neighbors
end

to-report format-time
  let minutes floor (evacuation-time / 60)
  let seconds evacuation-time mod 60
  report (word minutes ":" precision seconds 0)
end

; ==========
; VECTOR HELPERS
; ==========
to-report v-add [a b]
  report list (item 0 a + item 0 b) (item 1 a + item 1 b)
end

to-report v-sub [a b]
  report list (item 0 a - item 0 b) (item 1 a - item 1 b)
end

to-report v-scale [a s]
  report list (item 0 a * s) (item 1 a * s)
end

to-report v-scale-add [p vec s]
  report list (item 0 p + item 0 vec * s) (item 1 p + item 1 vec * s)
end

to-report limit-speed [a s]
  let m v-mag a
  if m > s [ report v-scale (unit a) s ]
  report a
end

to-report vector-to [tx ty]
  report list (tx - xcor) (ty - ycor)
end

to-report vector-from [sx sy tx ty]
  report list (sx - tx) (sy - ty)
end

;; helper: add weighted vec to accumulator
to-report v-plus [acc vec w]
  report v-add acc (v-scale vec w)
end

to-report v-distance [v1 v2]
  let d_x (item 0 v1 - item 0 v2)
  let d_y (item 1 v1 - item 1 v2)
  report sqrt (d_x ^ 2 + d_y ^ 2)
end

to-report normalize-vector [v]
  let mag v-mag v
  if mag = 0 [ report list 0 0 ]
  report list ((item 0 v) / mag) ((item 1 v) / mag)
end

to-report dot-product [v1 v2]
  report (item 0 v1) * (item 0 v2) + (item 1 v1) * (item 1 v2)
end

to-report O [z]
  ifelse z >= 0 [ report z ] [ report 0 ]
end

to-report v-mag [v]
  ;; expect v = [x y]; otherwise treat as zero vector
  if (not is-list? v) or (length v < 2) [
    report 0
  ]
  let x item 0 v
  let y item 1 v
  report sqrt (x * x + y * y)
end

to-report unit [v]
  ;; coerce bad inputs to [0 0]
  if (not is-list? v) or (length v < 2) [
    report (list 0 0)
  ]
  let m v-mag v
  if m = 0 [ report (list 0 0) ]
  report (list ((item 0 v) / m) ((item 1 v) / m))
end