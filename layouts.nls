;; POSSIBLE LAYOUTS - RANODM, CINEMA 

to setup-layout

  ;; ========== NODES & OBSTACLES & AGENTS ==========
  if layout-choice = "center-strip" [
    layout-center-strip
    spawn-none
  ]
  if layout-choice = "cinema" [
    layout-cinema
    spawn-cinema
  ]
  if layout-choice = "layout-a" [
    layout-none
    build-node-layout-a
    spawn-none
  ]
  if layout-choice = "layout-b" [ 
    layout-none
    build-node-layout-b
    spawn-none
  ]
  if layout-choice = "layout-c" [ 
    layout-none
    build-node-layout-c
    spawn-none
  ]
  if layout-choice = "layout-d" [ 
    layout-none
    build-node-layout-d
    spawn-none
  ]
  if layout-choice = "layout-e" [ 
    layout-none
    build-node-layout-e
    spawn-none
  ]
  if layout-choice = "layout-f" [ 
    layout-f
    spawn-none
  ]
  
  ;; ========== DOORS ==========
  setup-doors layout-choice
end


;; ========== DOOR SETUP ==========
to setup-doors [layout-name]
  let doors-list []

  if layout-name = "cinema" [ set doors-list doors-cinema ]
  if layout-name = "center-strip" [ set doors-list doors-center-strip ]
  if layout-name = "layout-a" [ set doors-list doors-layout-a ]
  if layout-name = "layout-b" [ set doors-list doors-layout-b ]
  if layout-name = "layout-c" [ set doors-list doors-layout-c ]
  if layout-name = "layout-d" [ set doors-list doors-layout-d ]
  if layout-name = "layout-e" [ set doors-list doors-layout-e ]
  if layout-name = "layout-f" [ set doors-list doors-layout-f ]
  
  let door-width 2
  let door-depth 1
  let half-width floor ((door-width / meters-per-patch) / 2)
  let half-depth floor ((door-depth / meters-per-patch) / 2)

  foreach doors-list [ exit-data ->
    let x round (item 0 exit-data)
    let y round (item 1 exit-data)
    let vis item 2 exit-data
    let id  item 3 exit-data

    ;; Determine orientation based on wall
    let horizontal? false
    if (y = max-pycor or y = min-pycor) [ set horizontal? true ]

    ;; Center patch
    if patch x y != nobody [
      ask patch x y [
        set is-exit? true
        set is-main-exit? true
        set exit-id id
        set node-id (word "exit-" id)
        set node-kind "next-node"
        set node-rule node-id
        set visibility (vis / meters-per-patch)
        set pcolor green
      ]
    ]

    ifelse horizontal? [
      ;; horizontal door along x-axis, expand perpendicular in y
      foreach (range (x - half-width) (x + half-width + 1)) [ xx ->
        let xx-round round xx
        foreach (range (y - half-depth) (y + half-depth + 1)) [ yy ->
          let yy-round round yy
          if patch xx-round yy-round != nobody [
            ask patch xx-round yy-round [
              set is-exit? true
              if xx-round != x or yy-round != y [ set is-main-exit? false ]
              set exit-id id
              set node-id (word "exit-" id)
              set node-kind "next-node"
              set node-rule node-id
              set visibility (vis / meters-per-patch)
              set pcolor green
            ]
          ]
        ]
      ]
    ] [
      ;; vertical door along y-axis, expand perpendicular in x
      foreach (range (y - half-width) (y + half-width + 1)) [ yy ->
        let yy-round round yy
        foreach (range (x - half-depth) (x + half-depth + 1)) [ xx ->
          let xx-round round xx
          if patch xx-round yy-round != nobody [
            ask patch xx-round yy-round [
              set is-exit? true
              if xx-round != x or yy-round != y [ set is-main-exit? false ]
              set exit-id id
              set node-id (word "exit-" id)
              set node-kind "next-node"
              set node-rule node-id
              set visibility (vis / meters-per-patch)
              set pcolor green
            ]
          ]
        ]
      ]
    ]
  ]
end

to draw-door-visibility
  clear-drawing
  
  ask patches with [is-exit? and is-main-exit?] [
    sprout 1 [
      set shape "circle empty"
      set color green
      set size visibility * 2
      stamp
      die
    ]
  ]
end


;; CENTER RANDOM STRIP
;; -------- CENTER STRIP --------
to layout-center-strip
  let obs-left-x   -5
  let obs-right-x   5
  let obs-lower-y  -10
  let obs-upper-y   10
  let obs-size-m    1

  set obs-left-x   (obs-left-x / meters-per-patch)
  set obs-right-x  (obs-right-x / meters-per-patch)
  set obs-lower-y  (obs-lower-y / meters-per-patch)
  set obs-upper-y  (obs-upper-y / meters-per-patch)
  let obs-size (obs-size-m / meters-per-patch)

  ask n-of 80 patches with [
    pxcor > obs-left-x and pxcor < obs-right-x and
    pycor mod 3 = 0 and
    pycor > obs-lower-y and pycor < obs-upper-y
  ] [
    sprout-obstacles 1 [
      set shape "box"
      set color gray
      set size obs-size
      set r (obs-size / 2)
    ]
  ]
end

to-report doors-center-strip
  ;; single door at top center as example
  let x 0
  let y (10 / meters-per-patch)
  report (list (list x y vis-door1 0))
end


to layout-cinema
  ;; ========== PARAMETERS ==========
  let seat-size-m       1        ;; meters per chair (vertical size of obstacle)
  let seat-spacing-m    0        ;; space between seats horizontally (meters)
  let row-spacing-m     0.7      ;; space between rows (meters) 
  let side-block-seats  5        ;; seats per lateral block (count of obstacles)
  let middle-block-seats 10      ;; seats in the center block (count of obstacles)
  let num-rows          12       ;; number of seat rows

  ;; Convert to patch coordinates (work with integers to align to patches)
  let seat-size (seat-size-m / meters-per-patch)
  let seat-spacing (seat-spacing-m / meters-per-patch)
  let row-spacing (row-spacing-m / meters-per-patch)

  let seat-size-patches round seat-size
  let seat-spacing-patches round seat-spacing
  let row-spacing-patches row-spacing  ;; keep fractional allowed for y stepping
  let step (seat-size-patches + seat-spacing-patches) ;; horizontal step between centers

  ;; World boundaries (patch coords)
  let left-wall min-pxcor
  let right-wall max-pxcor

  ;; starting y (bottom) — you were using bottom + offset
  let bottom min-pycor + 5
  let y bottom

  ;; skip the 2nd and 3rd to last rows:
  ;; indices run 0 .. num-rows-1; we skip i = num-rows-10 and i = num-rows-11
  let i 0
  repeat num-rows [
    if not (i = (num-rows - 10) or i = (num-rows - 11)) [
      ;; ---- LEFT BLOCK (touching left wall) ----
      ;; place the first seat center so the left edge of that seat touches the left wall
      ;; center offset from left wall:
      let left_center_offset round (seat-size-patches / 2)
      let left_start_x (left-wall + left_center_offset)

      ;; create left block seats left -> right
      let lx left_start_x
      repeat side-block-seats [
        create-seat lx y seat-size
        set lx lx + step
      ]

      ;; last left seat center:
      let last_left_center lx - step

      ;; ---- RIGHT BLOCK (touching right wall) ----
      let right_center_offset round (seat-size-patches / 2)
      let right_start_center (right-wall - right_center_offset)

      ;; place right block seats right -> left (we'll create them left-to-right below by computing the first center)
      let first_right_center (right_start_center - ( (side-block-seats - 1) * step) )
      let rx first_right_center
      repeat side-block-seats [
        create-seat rx y seat-size
        set rx rx + step
      ]

      ;; last right seat center is rx - step

      ;; ---- MIDDLE BLOCK (centered with equal aisles) ----
      let middle_width ((middle-block-seats - 1) * step)
      
      ;; Available space between last left and first right
      let available_space (first_right_center - last_left_center - middle_width)
      
      ;; Compute aisle width (evenly split the space)
      let aisle_width floor (available_space / 2)
      
      ;; Ensure at least 2 steps (minimum aisle size)
      if aisle_width < 2 [ set aisle_width 2 ]
      
      ;; Now recalculate middle placement based on centered aisles
      let middle_first_candidate (last_left_center + aisle_width)
      let middle_last_allowed (first_right_center - aisle_width)
      
      ;; Check if there's enough space (else compress)
      ifelse middle_last_allowed - middle_first_candidate < middle_width [
        ;; not enough space: compress seats
        ifelse middle-block-seats > 1 [
          let available (middle_last_allowed - middle_first_candidate)
          let compressed_step floor (available / (middle-block-seats - 1))
          if compressed_step < 1 [ set compressed_step 1 ]
          let mx middle_first_candidate
          repeat middle-block-seats [
            create-seat mx y seat-size
            set mx mx + compressed_step
          ]
        ] [
          ;; only one middle obstacle: place centered in available space
          let center_x round ((middle_first_candidate + middle_last_allowed) / 2)
          create-seat center_x y seat-size
        ]
      ] [
        ;; normal case: place middle block with regular step
        let mx middle_first_candidate
        repeat middle-block-seats [
          create-seat mx y seat-size
          set mx mx + step
        ]
      ]

    ]
    ;; next row (move upwards)
    set y y + seat-size + row-spacing
    set i i + 1
  ]
end

to-report doors-cinema
  ;; four doors: top left, top right, bottom left, bottom right
  let upper-y (10 / meters-per-patch)
  let lower-y (-8.5 / meters-per-patch)
  let left-x (-13 / meters-per-patch)
  let right-x (13 / meters-per-patch)

  report (list
    (list left-x  upper-y vis-door1 0)
    (list right-x upper-y vis-door2 1)
    (list left-x  lower-y vis-door3 2)
    (list right-x lower-y vis-door4 3)
  )
end 

to layout-f
  ;; Define in meters
  let obs-left-x   -4
  let obs-lower-y  -10
  let obs-upper-y   4
  let obs-size-m     1

  ;; Convert meters → patch coordinates
  set obs-left-x   (obs-left-x / meters-per-patch)
  set obs-lower-y  (obs-lower-y / meters-per-patch)
  set obs-upper-y  (obs-upper-y / meters-per-patch)
  let obs-size (obs-size-m / meters-per-patch)

  ;; --- Vertical line  ---
  foreach n-values (obs-upper-y - obs-lower-y + 1) [i -> obs-lower-y + i] [ y ->
    create-seat obs-left-x y obs-size
  ]

  ;; --- Diagonal line (starts at the top of the vertical) ---
  let start-x obs-left-x
  let start-y obs-upper-y + 25

  ;; Adjust the slope: 
  let diag-length 130  ;; number of obstacles on the diagonal
  let slope -0.85    ;; controls steepness (negative for down-right)

  foreach n-values diag-length [i -> i] [ i ->
    let px (start-x + i)
    let py (start-y + (slope * i))
    if (px <= max-pxcor and py >= min-pycor and py <= max-pycor) [
      create-seat px py obs-size
    ]
  ]
end


to create-seat [x y seat-size]
  ask patch round x round y [
    sprout-obstacles 1 [
      set shape "box"
      set color gray
      set size seat-size
      set r (seat-size / 2)
    ]
  ]
end
  
to layout-none
end

;; -------- LAYOUT A --------
to-report doors-layout-a
  ;; single door in top wall center
  let x 0
  let y (12 / meters-per-patch)
  report (list (list x y 50 0))
end

;; -------- LAYOUT B --------
to-report doors-layout-b
  ;; top wall center
  let top-x 0
  let top-y 12 / meters-per-patch

  ;; bottom wall center
  let bottom-x 0
  let bottom-y -12 / meters-per-patch

  ;; report both doors with visibility and exit ID (adjust as needed)
  report (list 
    (list top-x top-y 12 0)
    (list bottom-x bottom-y 12 1)
  )
end

;; -------- LAYOUT  C --------
to-report doors-layout-c
  ;; top wall center
  let top-x 0
  let top-y 12 / meters-per-patch

  ;; bottom wall center
  let bottom-x 0
  let bottom-y -12 / meters-per-patch

  ;; report both doors with visibility and exit ID (adjust as needed)
  report (list 
    (list top-x top-y 12 0)
    (list bottom-x bottom-y 3 1)
  )
end
;; -------- LAYOUT D --------
to-report doors-layout-d
  ;; two doors on left corners (top left and bottom left)
  let left-x (-13 / meters-per-patch)
  let top-y (12 / meters-per-patch)
  let bottom-y (-12 / meters-per-patch)
  report (list
    (list left-x top-y 3 0)
    (list left-x bottom-y 3 1)
  )
end 

;; -------- LAYOUT E --------
to-report doors-layout-e
  ;; left-top corner
  let left-x (-13 / meters-per-patch)
  let top-y (12 / meters-per-patch)

  ;; right-bottom corner
  let right-x (13 / meters-per-patch)
  let bottom-y (-12 / meters-per-patch)

  report (list
    (list left-x top-y 16.5 0)
    (list right-x bottom-y 16.5 1)
  )
end

;; -------- LAYOUT F --------
to-report doors-layout-f
  ;; single door in top wall center
  let x 0
  let y (12 / meters-per-patch)
  report (list (list x y 50 0))
end



to spawn-cinema
  ;; ============================
  ;; SPAWN AGENTS IN CINEMA LAYOUT
  ;; ============================

  ;; PARAMETERS
  let spread 0.05 / meters-per-patch  ;; small jitter for visual variety

  ;; group colors are initialized
  let size-colors [ orange blue green yellow red ]

  ;; Collect all chair turtles (obstacles)
  let chairs-list sort turtles with [breed = obstacles]

  ;; Shuffle chairs to randomize group placement
  let available-chairs shuffle chairs-list

  ;; Define group types as [total-members group-size]
  let all-groups (list
    (list In_groups_of_5 5)
    (list In_groups_of_4 4)
    (list In_groups_of_3 3)
    (list In_groups_of_2 2)
    (list In_groups_of_1 1)
  )

  ;; Loop over each group type
  foreach all-groups [ group-info ->
    let people-count first group-info
    let group-size last group-info

    if people-count > 0 and group-size > 0 [
      let num-groups people-count / group-size

      repeat num-groups [
        ;; Find a sequence of adjacent seats
        let selected-seats []
        let found? false

        ;; Try to find seats in the same row
        foreach available-chairs [ chair ->
          if not found? [
            let row-y [pycor] of chair
            let row-chairs sort-by [ [a b] -> [pxcor] of a < [pxcor] of b ] (filter [ x -> [pycor] of x = row-y ] available-chairs)

            ;; Check for enough adjacent seats
            if length row-chairs >= group-size [
              set selected-seats sublist row-chairs 0 group-size
              set found? true
            ]
          ]
        ]

        ;; If no adjacent seats found, pick nearest available chairs
        if not found? [
          set selected-seats sublist available-chairs 0 group-size
        ]

        ;; Remove selected seats from available chairs
        foreach selected-seats [ ch -> set available-chairs remove ch available-chairs ]

        ;; new group id/color
        set next-gid next-gid + 1
        let base-color item (group-size - 1) size-colors
        let gcol base-color + (random-float 7 - 3) 

        ;; spawn each member in the corresponding seat
        foreach selected-seats [ ch ->
          let cx [pxcor] of ch
          let cy [pycor] of ch + [r] of ch + 0.4 / meters-per-patch

          create-people 1 [
            ;; small jitter around chair
            let jitter-x (random-float spread - spread / 2)
            let jitter-y (random-float spread - spread / 2)
            setxy (cx + jitter-x) (cy + jitter-y)
            let myr (0.25 + random-float 0.15) / meters-per-patch

            initialize-agent-parameters group-size myr gcol
          ]
        ]
      ]
    ]
  ]
end


to spawn-none
  ;; PARAMETERS
  let spread 1.5 / meters-per-patch  ;; radius around group center
  let margin 2

  ;; ensure group colors are initialized
  let size-colors [ orange blue green yellow red ]

  ;; Define group types as [total-members group-size]
  let all-groups (list
    (list In_groups_of_5 5)
    (list In_groups_of_4 4)
    (list In_groups_of_3 3)
    (list In_groups_of_2 2)
    (list In_groups_of_1 1)
  )

  ;; Loop over each group type
  foreach all-groups [ group-info ->
    let people-count first group-info
    let group-size last group-info

    if people-count > 0 and group-size > 0 [
      let num-groups people-count / group-size

      repeat num-groups [
        ;; choose a fresh, random center for THIS group
        let center random-center-patch margin 200
        let cx [pxcor] of center
        let cy [pycor] of center

        ;; new group id/color
        set next-gid next-gid + 1
        let base-color item (group-size - 1) size-colors
        ;; add slight variation for this group only
        let gcol base-color + (random-float 7 - 3) 

        ;; create all members at once
        create-people group-size [
          let myr (0.25 + random-float 0.15) / meters-per-patch
          let pos find-safe-spot-around cx cy spread (myr)
          setxy item 0 pos item 1 pos
          
          initialize-agent-parameters group-size myr gcol
        ]
      ]
    ]
  ]
end

to initialize-agent-parameters [group-size myr gcol]
  ;; agent properties
  set size myr * 2
  set r myr
  set weight 70                                                              ;; TODO random number
                                                                             ;let dir unit (list (random-float 1 - 0.5) (random-float 1 - 0.5))
  set velocity (list (random-float 1 - 0.5) (random-float 1 - 0.5))
  set gamma random-float 0.1
  
  ;; behavioral parameters
  set ease-dist      10 * r
  set da             2 * r + 2 ;;neigh
  set dc             8 * r ;;neigh
  set dl             4 * r ;;neigh
  
  set goal-factor        20
  set cohesion-factor    1.5
  set separation-factor  2.5
  set alignment-factor   1.5
  set obstacle-factor    3.5
  
    ; ------- Group -------------------
  if Cohision-level = "High" [
    set cohesion-factor-group    1.5 * 1.5
    set separation-factor-group  2.5
    set alignment-factor-group   1.5 * 1.5
    set avoid_dist               r + 2 ;;group
  ]
  if Cohision-level = "Low" [
    set cohesion-factor-group    1.5 * 1.25
    set separation-factor-group  2.5 
    set alignment-factor-group   1.5 * 1.25
    set avoid_dist               1.25 * r + 2 ;;group
  ]
  ; ---------------------------------
  
  set group-id next-gid
  set group-color gcol
  set color group-color
  set gsize group-size
end
