; ==========
; BEHAVIOR COMPONENTS
; ==========
to-report goal-component 
  ; this needs to be change cause we have multipule exits also exits visibility needs to be included here
  ; if it's not visibule it should be (0,0)
  let gx [pxcor] of goal-pos
  let gy [pycor] of  goal-pos
  report unit (vector-to gx gy)
end

to-report cohesion-component
  ;for every agent in a spesific rediuos you want to go in a mean diraction of positioof the agents around you
  let ns other people with [group-id = [group-id] of myself] in-radius centroid_dist
  if any? ns [
    let cx mean [ xcor ] of ns
    let cy mean [ ycor ] of ns
    report unit (vector-to cx cy)
  ]
  report list 0 0
end

to-report separation-component
  ; 
  let ns other people with [group-id = [group-id] of myself] in-radius avoid_dist
  if any? ns [
    let away list 0 0
    foreach sort ns [ neighbor ->
      ask neighbor [
        ;; vector from neighbor to me (i.e., away from neighbor)
        set away v-add away (unit (vector-from [xcor] of myself [ycor] of myself xcor ycor))
      ]
    ]
    report unit away
  ]
  report list 0 0
end


to-report alignment-component
  let ns other people with [group-id = [group-id] of myself] in-radius alignment_dist
  if any? ns [
    let vx mean [ item 0 velocity ] of ns
    let vy mean [ item 1 velocity ] of ns
    report v-sub (list vx vy) velocity
  ]
  report list 0 0
end

to-report obstacle-component
  let obs obstacles in-radius ease-dist
  if any? obs [
    let away list 0 0
    foreach sort obs [ ob ->
      ask ob [
        set away v-add away (unit (vector-from [xcor] of myself [ycor] of myself xcor ycor))
      ]
    ]
    report unit away
  ]
  report list 0 0
end

to-report MOVE
      ;;;;;;;;;;;;;;; let v-goal goal-component
  let v-coh  cohesion-component
  let v-sep  separation-component
  let v-ali  alignment-component    
  let v-obs  obstacle-component

  ;; weighted sum of components
    ;;;;;;;;;;;;;;;; let v-new v-plus (list 0 0) v-goal mg
  let v-new v-plus (list 0 0) v-coh cohesion-factor
  set v-new v-plus v-new v-sep separation-factor
  set v-new v-plus v-new v-ali alignment-factor
  set v-new v-plus v-new v-obs obstacle-factor
  
  report v-new
end

; ==========
; OVERLAP & OBSTACULES
; ==========

;; True if my circle at (nx, ny) would overlap any neighbor's circle
to-report would-overlap? [nx ny myr]
  ;; Only check nearby agents to keep it fast:
  let candidates other turtles in-radius (myr + 2)   ;; inflate a bit; or use vmax*dt
  report any? candidates with [
    (distancexy nx ny) < (myr + r)   ;; r here is the neighbor's radius
  ]
end


; ==========
; PANIC UPDATE
; ==========
to update-panic
  ;; δ1: distance to goal vs ease distance
  let gx [pxcor] of goal-pos
  let gy [pycor] of goal-pos
  let D distancexy gx gy
  let L max (list world-width world-height)
  let delta1 max list 0 ((D - ease-dist) / L)

  ;; δ2: mismatch with neighbors
  let ns other people with [group-id = [group-id] of myself] in-radius alignment_dist
  let delta2 0
  if any? ns [
    let vmean list (mean [ item 0 velocity ] of ns) (mean [ item 1 velocity ] of ns)
    let mis v-mag (v-sub vmean velocity)
    set delta2 mis / vmax
  ]

  ;; δ3: neighbors in discomfort (proxy: very slow agents)
  let nsC other people with [group-id = [group-id] of myself] in-radius centroid_dist
  let delta3 0
  if any? nsC [
    set delta3 (count nsC with [ v-mag velocity < 0.2 * vmax ]) / (count nsC)
  ]

  ;; δ4: lagging compared to local min speed
  let vmin vmax
  if any? ns [ set vmin min (list vmin [ v-mag velocity ] of ns) ]
  let delta4 max list 0 ((vmin - v-mag velocity) / vmax)

  ;; Combine
  let zeta ((delta1 + delta2 + delta3 + delta4) / 4)
  set gamma ((1 - panic-smooth) * gamma + panic-smooth * zeta)
  set gamma max list 0 (min list 1 gamma)
end
