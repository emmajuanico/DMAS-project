; ==========
; BEHAVIOR COMPONENTS
; ==========

;; ========== GOAL ==========
to-report goal-component
  report rule-for-pos xcor ycor
end

;; ========== COHESION ==========
to-report group-cohesion-component
  ;for every agent in a spesific rediuos you want to go in a mean diraction of positioof the agents around you
  let ns other people with [group-id = [group-id] of myself]
  if any? ns [
    let cx mean [ xcor ] of ns
    let cy mean [ ycor ] of ns
    report vector-to cx cy
  ]
  report list 0 0
end

to-report neighbours-cohesion-component
  let ns other people with [group-id != [group-id] of myself] in-radius dc
  if any? ns [
    let cx mean [ xcor ] of ns
    let cy mean [ ycor ] of ns
    report vector-to cx cy
  ]
  report list 0 0
end

;; ========== SEPARATION ==========
to-report group-separation-component
  let ns other people with [ group-id = [group-id] of myself ] in-radius avoid_dist
  if any? ns [
    let away (list 0 0)
    ;; For each neighbor add unit vector from neighbor -> me
    foreach sort ns [ neighbor ->
      let ddx (xcor - [xcor] of neighbor)
      let ddy (ycor - [ycor] of neighbor)
      ;; If neighbor is exactly on same spot, create a small random vector
      if (ddx = 0 and ddy = 0) [
        set ddx (random-float 1 - 0.5)
        set ddy (random-float 1 - 0.5)
      ]
      set away v-add away (unit (list ddx ddy))
    ]
    report away
  ]
  report list 0 0
end

to-report neighbours-separation-component
  let ns other people with [ group-id != [group-id] of myself ] in-radius da
  if any? ns [
    let away (list 0 0)
    foreach sort ns [ neighbor ->
      let ddx (xcor - [xcor] of neighbor)
      let ddy (ycor - [ycor] of neighbor)
      if (ddx = 0 and ddy = 0) [
        set ddx (random-float 1 - 0.5)
        set ddy (random-float 1 - 0.5)
      ]
      set away v-add away (unit (list ddx ddy))
    ]
    report away
  ]
  report list 0 0
end

;; ========== ALIGNMENT ==========
to-report groups-alignment-component
  let ns other people with [group-id = [group-id] of myself]
  if any? ns [
    let vx mean [ item 0 velocity ] of ns
    let vy mean [ item 1 velocity ] of ns
    report v-sub (list vx vy) velocity
  ]
  report list 0 0
end

to-report neighbours-alignment-component
  let ns other people with [group-id != [group-id] of myself] in-radius dl
  if any? ns [
    let vx mean [ item 0 velocity ] of ns
    let vy mean [ item 1 velocity ] of ns
    report v-sub (list vx vy) velocity
  ]
  report list 0 0
end

;; ========== OBSTACLE ==========
to-report obstacle-component
  let obs obstacles in-radius ease-dist
  if any? obs [
    let away list 0 0
    foreach sort obs [ ob ->
      ask ob [
        set away v-add away (unit (vector-from [xcor] of myself [ycor] of myself xcor ycor))
      ]
    ]
    report unit away
  ]
  report list 0 0
end

; ==========
; MOVE
; ==========

to-report MOVE
  ;;;;;;;;;;;;;;; let v-goal goal-component
  ;;cohesion
  let v-coh-g group-cohesion-component
  let v-coh-n neighbours-cohesion-component

  ;separation
  let v-sep-g group-separation-component
  let v-sep-n neighbours-separation-component
  
  ;alignment
  let v-ali-g groups-alignment-component
  let v-ali-n neighbours-alignment-component 
  
  let v-obs  obstacle-component
  
  ;;numeric weights
  let group-weight      1.0
  let neighbour-weight  0.4

  ;; weighted sum of components
  ;;;;;;;;;;;;;;;; let v-new v-plus (list 0 0) v-goal mg
  let v-new (list 0 0)
  set v-new v-plus v-new v-coh-g (cohesion-factor * group-weight)
  set v-new v-plus v-new v-coh-n (cohesion-factor * neighbour-weight)
  set v-new v-plus v-new v-sep-g (separation-factor * group-weight)
  set v-new v-plus v-new v-sep-n (separation-factor * neighbour-weight)
  set v-new v-plus v-new v-ali-g (alignment-factor * group-weight)
  set v-new v-plus v-new v-ali-n (alignment-factor * neighbour-weight)
  set v-new v-plus v-new v-obs obstacle-factor
  
  report v-new
end

; ==========
; OVERLAP & OBSTACLES
; ==========
;; True if a circle of radius `myr` at (nx, ny) is inside the world
;; and does not overlap any other turtle’s circle.
to-report safe-spot? [nx ny myr]
  ;; 1) inside boundaries?
  if not (nx > min-pxcor and nx < max-pxcor and ny > min-pycor and ny < max-pycor) [
    report false
  ]

  ;; 2) overlap with other people/turtles?
  ;; consider only nearby turtles for speed
  let nearby-turtles other turtles in-radius (myr + 4) ;; loose radius for candidate search
  if any? nearby-turtles [
    ;; check pairwise with their radius attribute
    if any? nearby-turtles with [
      (distancexy nx ny) < (myr + r)
    ] [
      report false
    ]
  ]

  ;; passed all checks
  report true
end



; ==========
; PANIC UPDATE
; ==========
to update-panic
  ;----------------------------------------------
  ;; δ1: distance to goal vs ease distance
  ;; compute distance to closest visible exit
  let visible-exits patches with [
    is-exit? and distance myself <= visibility
  ]
  let D 0
  
  if any? visible-exits [
    let closest min-one-of visible-exits [ distance myself ]
    set D distance closest
  ] 
  ;; if no exit is visible, use nearest exit anyway
  if not any? visible-exits [
    let closest min-one-of patches with [is-exit?] [ distance myself ]
    set D distance closest
  ]
  
  let L max (list world-width world-height)
  let delta1 max list 0 ((D - ease-dist) / L)
  
  ;----------------------------------------------
  ;; δ2: mismatch with group
  let ns other people with [group-id = [group-id] of myself] in-radius alignment_dist
  let delta2-group 0
  if any? ns [
    let vmean list (mean [ item 0 velocity ] of ns) (mean [ item 1 velocity ] of ns)
    let mis v-mag (v-sub vmean velocity)
    set delta2-group mis / vmax
  ]
  
  ;; δ2: mismatch with neighbours
  let ns2 other people with [group-id != [group-id] of myself] in-radius alignment_dist
  let delta2-neigh 0
  if any? ns [
    let vmean list (mean [ item 0 velocity ] of ns) (mean [ item 1 velocity ] of ns)
    let mis v-mag (v-sub vmean velocity)
    set delta2-neigh mis / vmax
  ]
  
  ;----------------------------------------------
  ;; δ3: group in discomfort (proxy: very slow agents)
  let nsC other people with [group-id = [group-id] of myself] in-radius centroid_dist
  let delta3-group 0
  if any? nsC [
    set delta3-group (count nsC with [ v-mag velocity < 0.2 * vmax ]) / (count nsC)
  ]
  
  ;; δ3: neighbors in discomfort (proxy: very slow agents)
  let nsC2 other people with [group-id = [group-id] of myself] in-radius centroid_dist
  let delta3-neigh 0
  if any? nsC [
    set delta3-neigh (count nsC with [ v-mag velocity < 0.2 * vmax ]) / (count nsC)
  ]

  ;----------------------------------------------
  ;; δ4: lagging compared to local min speed - group
  let vmin vmax
  if any? ns [ set vmin min (list vmin [ v-mag velocity ] of ns) ]
  let delta4-group max list 0 ((vmin - v-mag velocity) / vmax)
  
  ;; δ4: lagging compared to local min speed - neighbours
  let vmin2 vmax
  if any? ns [ set vmin min (list vmin [ v-mag velocity ] of ns) ]
  let delta4-neigh max list 0 ((vmin - v-mag velocity) / vmax)

  
  ;----------------------------------------------
  ;; Combine
  let zeta ((delta1 + 0.66 * (delta2-group + delta3-group + delta4-group) + 0.33 * (delta2-neigh + delta3-neigh + delta4-neigh)) / 4)
  set gamma ((1 - panic-smooth) * gamma + panic-smooth * zeta)
  set gamma max list 0 (min list 1 gamma)
end
